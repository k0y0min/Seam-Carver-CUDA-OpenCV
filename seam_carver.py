import numpy as np
from PIL import Image

def compute_energy(image: np.ndarray):
    #forward energy
    R = np.roll(image, 1, axis=0) 
    L = np.roll(image, -1, axis=0)
    U = np.roll(image, 1, axis=1)
    D = np.roll(image, -1, axis=1)

    dx_sq = np.square(R-L)
    dy_sq = np.square(U-D)
    delta_sq = np.sum(dx_sq, axis = 2, dtype = np.double) + np.sum(dy_sq, axis = 2, dtype = np.double)
    energy = np.sqrt(delta_sq)

    #border pixels set to 1000
    energy[:,0] = 1000
    energy[0,:] = 1000
    energy[image.shape[0]-1, :] = 1000
    energy[:, image.shape[1]-1] = 1000

    return energy

def find_vertical_seam(image: np.ndarray, energy=None):
    if energy is None:
        energy = compute_energy(image)
        # Add a small random noise to the energy, which is generated by
        # an image assumed to contain integer values between [0, 255]
        # (thus may contain many duplicate values), to avoid variations
        # between implementations yielding different results.

        # Storing the internal random state for later reversion
        random_state = np.random.get_state()
        # Seeding the random state to 0
        np.random.seed(0)
        # generating the random noise
        noise = np.random.randn(*energy.shape) / (1000 * (image.size ** (0.5)))
        energy = energy + noise
        # Reverting the random state to what we started with
        np.random.set_state(random_state)

    r, c = energy.shape
    sol = np.zeros((r,c), dtype = int)
    cM = energy.copy()
    min_seam = np.zeros(r, dtype= int)

    for i in range(1, r):
        for j in range(0, c):
            if j == 0:
                t = np.argmin(cM[i - 1, j:j + 2])
                sol[i, j] = t + j
                min_energy = cM[i - 1, t + j]
            else:
                t = np.argmin(cM[i - 1, j - 1:j + 2])
                sol[i, j] = t + (j - 1)
                min_energy = cM[i - 1, t + j - 1]

            cM[i, j] += min_energy
    
    j = np.argmin(cM[-1])
    for i in reversed(range(r)):
        min_seam[i] = j
        j = sol[i, j]
    
    return min_seam

def find_horizontal_seam(image: np.ndarray, energy=None):
    # this is equivalent to finding the vertical seam on the transposed image
    # so we don't need to repeat ourselves
    return find_vertical_seam(image.transpose(1, 0, 2), energy=energy)


def main():
    """
    Generate a visualization of the energy and 2 visualizations
    of the seam carving algorithm.
    """
    # open image with pillow, an active fork of the defunct PIL library
    p = Image.open("InputImage.jpg")
    # image could be other modes like RGBA, YCbCr, or L or something
    p = p.convert(mode="RGB")
    # limit max size
    #p.thumbnail(size=(800, 500))
    R, G, B = 0, 1, 2

    # -------------------- energy -------------------------------

    # convert image to an array. Since default datatype for an RGB
    # image is in unsigned 8 bit integer, convert it to a regular int
    # to avoid hard-to-debug shenanigans like over/underflow
    image = np.array(p).astype(int)
    # compute the energy. Since the boundary is 1000 and would reduce
    # the visibility of the more interesting parts after normalization,
    # crop the "frame" **to improve visualization**
    energy = compute_energy(image)[1:-1, 1:-1]
    # energy = np.log(energy + 1)

    # normalization **for visualization**
    # darken the least value to black
    energy -= np.min(energy)
    # lighten the greatest value to white
    energy = energy / np.max(energy)
    # fit the value between [0, 255]
    energy *= 256
    energy = np.floor(energy)
    energy[energy == 256] = 255

    # convert values to an image
    energy_visualization = Image.fromarray(energy.astype(np.uint8), mode="L")
    energy_visualization.save("energy.png")

    # -------------------- vertical carving ---------------------

    # for an image of shape (height, width, channel)
    # build a visualization by gradually carving axis 1
    image = np.array(p).astype(int)
    original_shape = image.shape

    # sequence of frames to be animated
    sequence = []

    # cap number of seams to carve at 200
    for _ in range(min([200, original_shape[1]])):
        # Create a frame for the seam to be carved away in red
        vertical_indices = tuple(np.arange(image.shape[0]))
        horizontal_indices = tuple(find_vertical_seam(image))
        image[vertical_indices, horizontal_indices, R] = 255
        image[vertical_indices, horizontal_indices, G] = 0
        image[vertical_indices, horizontal_indices, B] = 0

        # append black pixels to make up for pixels carved away
        sequence.append(Image.fromarray(
            np.append(image, np.zeros((
                original_shape[0],
                original_shape[1] - image.shape[1],
                original_shape[2],
            )), axis=1).astype(np.uint8)
        ))

        # carve the seam with a mask and reshape operation
        mask = np.full(image.shape, True, dtype=bool)
        mask[vertical_indices, horizontal_indices] = False

        image = image[mask].reshape((
            image.shape[0],
            image.shape[1] - 1,
            image.shape[2]
        ))

        # append black pixels to make up for pixels carved away
        sequence.append(Image.fromarray(
            np.append(image, np.zeros((
                original_shape[0],
                original_shape[1] - image.shape[1],
                original_shape[2],
            )), axis=1).astype(np.uint8)
        ))

    # save the final, carved image
    final_image = Image.fromarray(image.astype(np.uint8))
    final_image.save("vertical_carving_final.png")

    # build GIF
    p.save(
        "vertical_carving.gif",
        save_all=True,
        append_images=sequence,
        # to create infinite looping GIF
        loop=0 
        # to control the speed of GIF
        # duration=40,
    )

    # -------------------- horizontal carving -------------------

    # for an image of shape (height, width, channel)
    # build a visualization by gradually carving axis 0
    image = np.array(p).astype(int)
    original_shape = image.shape

    # sequence of frames to be animated
    sequence = []

    # cap number of seams to carve at 200
    for _ in range(min([200, original_shape[0]])):
        # Create a frame for the seam to be carved away in red
        vertical_indices = tuple(find_horizontal_seam(image))
        horizontal_indices = tuple(np.arange(image.shape[1]))
        image[vertical_indices, horizontal_indices, R] = 255
        image[vertical_indices, horizontal_indices, G] = 0
        image[vertical_indices, horizontal_indices, B] = 0

        # append black pixels to make up for pixels carved away
        sequence.append(Image.fromarray(
            np.append(image, np.zeros((
                original_shape[0] - image.shape[0],
                original_shape[1],
                original_shape[2],
            )), axis=0).astype(np.uint8)
        ))

        # carve the seam with a mask and reshape operation
        mask = np.full(image.shape, True, dtype=bool)
        mask[vertical_indices, horizontal_indices] = False

        # don't look at me I am hideous
        # (weird hack to make sure that pixels line up right)
        image = image.transpose(1, 0, 2)[mask.transpose(1, 0, 2)].reshape((
            image.shape[1],
            image.shape[0] - 1,
            image.shape[2],
        )).transpose(1, 0, 2)

        # append black pixels to make up for pixels carved away
        sequence.append(Image.fromarray(
            np.append(image, np.zeros((
                original_shape[0] - image.shape[0],
                original_shape[1],
                original_shape[2],
            )), axis=0).astype(np.uint8)
        ))

    # save the final, carved image
    final_image = Image.fromarray(image.astype(np.uint8))
    final_image.save("horizontal_carving_final.png")

    # build GIF
    p.save(
        "horizontal_carving.gif",
        save_all=True,
        append_images=sequence,
        # uncomment this line to create infinite looping GIF
        # loop=0,
        # uncomment this line to control the speed of GIF
        # duration=40,
    )

if __name__ == "__main__":
    main()
